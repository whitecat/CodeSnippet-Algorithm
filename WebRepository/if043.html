<html>

<head>
<title>Java Analysis Studio</title>
<meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<meta NAME="GENERATOR" CONTENT="Microsoft FrontPage 5.0">
<link rel="stylesheet" type="text/css" href="users-guide.css">
</head>

<body>

<h2>Java Mini-Tutorial</h2>

<h3>Contents</h3>

<blockquote>
  <ul>
    <li><a href="#Introduction">Introduction</a></li>
    <li><a href="#Classes, Objects, Methods and Constructors">Classes, Objects, Methods and
      Constructors</a></li>
    <li><a href="#Inheritance">Inheritance</a></li>
    <li><a href="#Classes and Interfaces">Classes vs. Interfaces</a></li>
    <li><a href="#Packages">Packages</a></li>
    <li><a href="#Protection">Protection - public, protected, private</a></li>
    <li><a href="#Variables">Variables</a></li>
    <li><a href="#Operators and Expressions">Operators and Expressions</a></li>
    <li><a href="#Conditonal and Loop Statements">Conditional and Loop Statements</a></li>
    <li><a href="#Mathematical Functions">Mathematical Functions</a></li>
    <li><a href="#Strings">Strings</a></li>
    <li><a href="#Arrays">Arrays</a></li>
    <li><a href="#Exceptions">Exceptions</a></li>
  </ul>
</blockquote>

<h3><a name="Introduction">Introduction</a></h3>

<p>In this chapter we provide a brief overview of the Java Programming Language. The
tutorial presented here is intended to introduce readers to just enough Java to write
physics analysis routines for Java Analysis Studio, and is far from a complete Java
tutorial (for more detailed tutorials see the <a href="#References">references</a> at the
end of this chapter). No prior knowledge of Java or object-oriented programming is
assumed. Readers already familiar with C or C++ should find the contents very 
familiar.</p>

<p>The Java programming language is an object-oriented language developed by Sun, and
popularized by its introduction as a way of programming &quot;web applets&quot; in
Netscape and other browsers. Java code is compiled into a
machine-independent-pseudo-machine-code called <span class="dfn">bytecodes</span>. By
convention Java source code is kept in files with extension <code>.java</code>, and the bytecodes
generated by compiling the source are kept in files with extension <code>.class</code>. Since Java
bytecodes are machine independent they can be run on any machine, and can easily be moved
from machine to machine over a network. Java Analysis Studio makes use of this feature to
allow analysis code to be written and compiled on the desktop machine, and then either
executed locally or moved to a data server to be executed. When Java bytecodes are
executed on a particular machine they are normally converted to native machine code at
runtime, a process known as <span class="dfn">Just-In-Time </span>(JIT) compilation. Thus
analysis code written in Java can attain execution speeds not too far removed from
compiled code and considerably faster than interpretive languages previously used for
physics analysis, such as COMIS and IDA. The compile/load speed of Java is very fast, so
the turnaround time for modifying-compiling-reloading and running analysis code in Java is
also very good.</p>

<h3><a name="Classes, Objects, Methods and Constructors">Classes, Objects, Methods and
Constructors</a></h3>

<p>Since Java is a pure object-oriented language all code is written as <span class="dfn">classes</span>.
A class typically represents a set of concrete or abstract items, such as Histograms,
Cuts, Particles, or Event Analyzers. <span class="dfn">Objects</span> represent a specific
instance of an item contained within the set, thus a specific histogram may be represented
by an object of class Histogram. (By convention classes are given capitalized names, while
objects are spelt with an initial lowercase letter). Procedures within classes are called <span class="dfn">methods</span>, thus a Histogram class would typically contain methods for
filling the histogram as well as methods for extracting information about the histogram.
Classes normally have one or more <span class="dfn">constructors</span>, which are methods
used to create new objects of that class. Constructors always have the same name as the
class itself, and unlike other methods they cannot return a value (since they implicitly
return a new object).</p>

<p>To create a very simple Histogram class in Java one could write:</p>

<pre><span class="key">public class</span> Histogram
{
   Histogram(String name)
   {
      m_name = name;
   }
   <span class="key">public</span> String getName()
   {
      <span class="key">return</span> m_name;
   }
   <span class="key">public void</span> fill(<span class="key">double</span> value, <span class="key">double</span> weight)
   {
      <span class="comment">// fill bins here</span>
   }
   <span class="key">private</span> String m_name;
}
</pre>

<p>This code declares a class called Histogram. The class is declared <span class="dfn">public</span>
meaning that anyone can access the Histogram class. The histogram class contains one
constructor, which by convention has the same name as the name of the class. In this case
the constructor takes a single argument of type String, which is stored into the variable
m_name. Note that m_name is declared at the level of the class itself, rather than inside
any of the methods, which indicates that the variable is a <span class="dfn">member
variable</span>. Member variables have the same life-span as the objects which contain
them, thus whenever an object of class Histogram is created one string variable m_name
will be created within that object, and the variable will maintain its value until that
object is destroyed. m_name is declared <span class="dfn">private</span>, meaning that it
can only be accessed directly from within the Histogram class itself.</p>

<p>Our example Histogram class contains a second method, fill, which takes two arguments,
the bin to fill (value) and the weight to add to that bin. For simplicity the body of the
function is omitted (fortunately we don&#146;t really need to write our own Histogram class since
Java Analysis Studio already contains a fully functional histogram class which we can just
use!).</p>

<p>Note that all statements in Java must end with a semi-colon, and that squiggly-brackets
({}) are used to delimit the beginning and end of blocks of code, such as the bodies of
functions. Double slashes are used to begin single line comments. (Anyone familiar with C
or C++ will notice that most Java conventions are exactly the same as for those
languages.)</p>

<p>In Java, objects of a particular class are created by using the <span class="dfn">new</span>
keyword. Thus to create and fill a histogram in Java one would write: </p>

<pre>   Histogram myhist = <span class="key">new</span> Histogram(<span class="string">&quot;My Histogram&quot;</span>);
   myhist.fill(99.0,1.0);</pre>

<p>In the first line above a local variable myhist is declared, which is of type
Histogram, and which is assigned a new histogram object (named &quot;My Histogram&quot;).
In the second line the fill method of the histogram object is invoked. In Java it is not
necessary (or possible) to explicitly delete an object, rather the object will be
automatically destroyed once there are no active references to it (a process known as <span class="dfn">garbage collection</span>).</p>

<h3><a name="Inheritance">Inheritance</a></h3>

<p>One of the most powerful features of object-oriented languages is the concept of <span class="dfn">inheritance</span>, whereby one class may inherit all or a subset of the
methods and member variables of a <span class="dfn">super-class.</span> For example we could
implement a BetterHistogram class as follows:</p>

<pre><span class="key">public class</span> BetterHistogram <span class="key">extends</span> Histogram
{
   BetterHistogram(String name)
   {
      <span class="key">super</span>(name);
   }
   <span class="key">public void</span> fill(<span class="key">double</span> value, <span class="key">double</span> weight)
   {
      m_nEntries++;
      <span class="key">super</span>.fill(value,weight);
   }
   <span class="key">public int</span> getNEntries()
   {
      <span class="key">return</span> m_nEntries;
   } 
   <span class="key">private int</span> m_nEntries = 0;
}</pre>

<p>In this example the class BetterHistogram is declared as extending Histogram, which
means that in inherits all of the methods and member variables of the Histogram class, but
can, in addition, add its own methods and member variables. All classes implicitly inherit
from the base class <a href="http://java.sun.com/products/jdk/1.1/docs/api/java.lang.Object.html#_top_">Object</a><a href="http://java.sun.com/products/jdk/1.1/api/java.lang.String.html" target="_top"><img alt="(in the API reference documentation)" border="0" height="20" src="apiIcon.gif" width="20"></a> which is built-in to the Java language. </p>

<p>Java classes can only extend one super-class (<cite>i.e</cite>. Java does not support <span class="dfn">multiple-inheritance</span>) 
although they can implement any number of interfaces (see
<a href="#Classes and Interfaces">below</a>). </p>

<p>When using Java Analysis Studio the most common way in which you will encounter
inheritance is when you write your own event analysis routines. Java Analysis Studio
contains a built-in class 
<a target="_top" href="../api/Hep/hep/analysis/EventAnalyzer.html">EventAnalyzer<img alt="(in the API reference documentation)" border="0" height="20" src="apiIcon.gif" width="20"></a>, which can be thought of as 
an empty framework for
performing event analysis. The class contains methods which are called to process each
event (processEvent) and which are called at the beginning and end of each run
(beforeFirstEvent and afterLastEvent) but each of these methods is empty, meaning that it
does not actually perform any data analysis (or anything else). The purpose of a framework
class such as EventAnalyser is to allow you to extend it, for example to provide
a MyEventAnalysis class which actually does something useful (your physics analysis). For
example:</p>

<pre><span class="key">public class</span> MyAnalysis <span class="key">extends</span> EventAnalyzer
{
   <span class="key">public void</span> processEvent(EventData d)
   {  
      <span class="comment">// perform analysis and fill histograms here.</span>
   }
}</pre>

<h3><a name="Classes and Interfaces">Classes vs. Interfaces</a></h3>

<p>As mentioned above classes in Java can only extend a single super-class. 
However, in addition to classes Java supports a second concept called an
<span class="dfn">interface</span>. Like classes interfaces define a set of 
methods, but unlike classes they can not contain any implementation of these 
methods. (Interfaces in Java are very similar to pure-virtual classes in C++).</p>

<p>The following is an example of an interface.</p>

<pre><span class="key">public interface</span> FourVector
{
   <span class="key">public double</span> x();
   <span class="key">public double</span> y();
   <span class="key">public double</span> z();
   <span class="key">public double</span> t();
   public double magnitude();
}</pre>
<p>What the above means is that anything which calls itself an FourVector must 
provide implementations of each of the methods specified in the interface. A 
class can be declared to provide an implementation of an interface using the
<span class="dfn">implements</span> keyword. For example:</p>
<pre><span class="key">public class</span> Particle <span class="key">implements</span> FourVector
{
   <span class="key">private double</span> px, py, pz, mass;
   <span class="key">public</span> Particle(<span class="key">double</span> px, <span class="key">double</span> py, <span class="key">double</span> pz, <span class="key">double</span> mass)
   {
      <span class="key">this</span>.px = px;
      <span class="key">this</span>.py = py;
      <span class="key">this</span>.pz = pz;
      <span class="key">this</span>.mass = mass;
   }
   <span class="key">public double</span> x() { <span class="key">return</span> x; }
   <span class="key">public double</span> y() { <span class="key">return</span> y; }
   <span class="key">public double</span> z() { <span class="key">return</span> z; }
   <span class="key">public double</span> t() { <span class="key">return</span> mass; }
   <span class="key">public double</span> magnitude() 
   {
      <span class="key">return</span> Math.sqrt(x*x + y*y + z*z + mass*mass);
   }
}</pre>
<p>A single class can provide an implementation of any number of interfaces. As 
far as the user of an interface is concerned, they work exactly the same as 
classes, so with the above definitions you can write:</p>
<pre>FourVector v = <span class="key">new</span> Particle(1,2,3,0.5);
<span class="key">double</span> e = v.magnitude(); </pre>
<h3><a name="Packages">Packages</a></h3>

<p>Classes in Java are normally defined inside <span class="dfn">packages</span>. Packages have two
functions</p>

<ol>
  <li>They group sets of classes together. A package normally contains a group 
  of classes that work together to achieve some well defined functionality.</li>
  <li>The define a hierarchical name-space, so that classes with the same name
    will not clash with each other so long as they are defined in different packages.</li>
</ol>
<p>For example the full name of the String class is java.lang.String,
indicating that it is in the java.lang package. By convention package names are
always in lower case (a convention which is just about universally followed),
and by convention should be named using the reversed domain name of
the creating organization, for example <code>edu.stanford.slac.jas.Histogram</code> (a
convention often ignored since it can lead to unwieldy package names - and not
everyone has their own domain name).&nbsp;</p>
<p>When defining a class you will normally start your .java file with a 
<span class="dfn">package</span> statement:</p>
<pre><span class="key">package</span> my.analysis;</pre>
<p>This statement implies that any classes defined inside the file are
considered to be in package my.analysis. If you do not put a package statement
in your file your classes will be considered to be in the &quot;unnamed
package&quot;. In general the unnamed package is good for quick tests and
experimenting, but for code that you expect to use longer term an explicit
package statement is a good idea.</p>
<p>Wherever a class name appears you can use the full name including package
name, however this leads to a lot of typing and can adversely effect the clarity
of your code. As an alternative you can use <span class="dfn">import</span> statements 
following the package statement at the top of your
program. For example:</p>
<pre><span class="key">import</span> java.lang.String;
<span class="key">import</span> java.lang.*;</pre>

<p>The first line imports a specific class, the second line imports all of the
classes in package java.lang. Once you have imported a class you can refer to it
by its short name (e.g. String). If you import two packages which contain a
class with the same name you will still need to refer to it using its fully
qualified name. Note that in reality you do not ever need to import package
java.lang since it is unique in always being considered to be implicitly
imported. The package statement, if it exists, must be the first statement in
the file, and must be immediately followed by any import statements.</p>

<p>Java requires that a class whose full name is my.analysis.Histogram be 
defined in a file called Histogram.java which resides in a directory 
my/analysis. ie:</p>

<p align="center">&nbsp;<img border="0" src="folder.gif" WIDTH="135" HEIGHT="51"></p>

<h3><a name="Protection">Protection - public, protected, private</a></h3>

<p>Methods and member variables within Java classes can have <span class="dfn">access modifiers</span>
applied to them, that control where they can by used from. The allowed access modifiers
are:</p>

<ul>
  <li><b>public</b> - Anyone can access the method/variable</li>
  <li><b>protected</b> - The method/variable can only be accessed by classes 
  which inherit from the class in which the method/variable is declared.</li>
  <li><b>private</b> - The method/variable can only be accessed from within the
    class where it is declared.</li>
  <li>default - If a member variable is not declared public, protected or 
  private, then it is said to have default protection. In this case it can be 
  accessed by any class in the same package, but not by any other classes. (This 
  is sometimes also called <span class="dfn">package private</span> protection).</li>
</ul>

<h3><a name="Variables">Variables</a></h3>

<p>In Java there are only two types of variables, <span class="dfn">intrinsic</span> and <span class="dfn">reference</span> types. Intrinsic variables are those that refer to built-in
simple types of variables, such as int, double, float, boolean. A complete list of
built-in types is given in the following table:</p>

<table BORDER="1" CELLSPACING="1" CELLPADDING="7" width="80%">
  <tr>
    <th VALIGN="top">Type</th>
    <th VALIGN="top">Description</th>
  </tr>
  <tr>
    <td VALIGN="TOP"><code>byte</code></td>
    <td VALIGN="TOP">8-bit signed integer.</td>
  </tr>
  <tr>
    <td VALIGN="TOP"><code>short</code></td>
    <td VALIGN="TOP">16-bit signed integer. </td>
  </tr>
  <tr>
    <td VALIGN="TOP"><code>int</code></td>
    <td VALIGN="TOP">32-bit signed integer.</td>
  </tr>
  <tr>
    <td VALIGN="TOP"><code>long</code></td>
    <td VALIGN="TOP">64-bit signed integer. </td>
  </tr>
  <tr>
    <td VALIGN="TOP"><code>float</code></td>
    <td VALIGN="TOP">32-bit IEEE754 floating-point. </td>
  </tr>
  <tr>
    <td VALIGN="TOP"><code>double</code></td>
    <td VALIGN="TOP">64-bit IEEE754 floating-point. </td>
  </tr>
  <tr>
    <td VALIGN="TOP"><code>char</code></td>
    <td VALIGN="TOP">16-bit Unicode character. Unicodes are extensions to ASCII to support
    international character sets. <a href="http://www.unicode.org/">(Click here for
    information about Unicodes.)</a> </td>
  </tr>
  <tr>
    <td VALIGN="TOP"><code>boolean</code></td>
    <td VALIGN="TOP">A true or false value, using the keywords <code>true</code> and <code>false</code>
    -- pretty clever. There is no conversion between booleans and other types, such as <code>int</code>'s.</td>
  </tr>
</table>

<p>Note that Java completely defines the size and behavior of all built-in types, so they
should behave identically on all platforms. When intrinsic variables are passed to
functions they are always passed by value, thus the variable within the function is
initially set to the value of the passed argument, but subsequent changes to the variable
inside the function will have no effect on the value of the variable passed in.</p>

<p>The only other type of variable in Java is a reference to an object. References
variables either always point to an object of a particular type, or have the special value
<span class="dfn">null</span>. Objects are only created if the new operator is explicitly
used, the assignment operator just creates two references to the same object. Thus the
statements:</p>

<pre>Histogram a = new Histogram(&quot;my histogram&quot;);
Histogram b = a;</pre>

<p>create one histogram object and sets variables a and b to point to the same histogram
object. Therefore modifying the object pointed to by <code> a</code> will also modify the object pointed
to by <code> b</code> (since they are the same object). This can be a little confusing until one gets
used to it, for example:</p>

<pre>Histogram a = <span class="key">new</span> Histogram(&quot;my histogram&quot;);
Histogram b = a;
b.fill(1.0);
System.out.println(<span class="string">&quot;a has &quot;</span>+a.getNEntries()+<span class="string">&quot; entries&quot;</span>);</pre>

<p>will print 1 not 0.</p>

<h3><a name="Operators and Expressions">Operators and Expressions</a></h3>

<h4>Arithmetic operators</h4>

<p>The arithmetic operators in Java are almost identical to those in C or C++. These
arithmetic operators can be used on any integer or floating point operands. The operands
will be automatically promoted as necessary (thus adding an int and a double will produce
a double).</p>

<table border="1" cellPadding="5">
  <tr>
    <th width="61">Operator</th>
    <th width="100">Use</th>
    <th width="365">Description</th>
  </tr>
  <tr>
    <td width="61"><code>+</code></td>
    <td width="100"><code>op1 + op2</code> </td>
    <td width="365">Adds <tt>op1</tt> and <tt>op2</tt> </td>
  </tr>
  <tr>
    <td width="61"><code>-</code></td>
    <td width="100"><code>op1 - op2 </code></td>
    <td width="365">Subtracts <tt>op2</tt> from <tt>op1</tt> </td>
  </tr>
  <tr>
    <td width="61"><code>*</code></td>
    <td width="100"><code>op1 * op2</code> </td>
    <td width="365">Multiplies <tt>op1</tt> by <tt>op2</tt> </td>
  </tr>
  <tr>
    <td width="61"><code>/</code></td>
    <td width="100"><code>op1 / op2</code> </td>
    <td width="365">Divides <tt>op1</tt> by <tt>op2</tt> </td>
  </tr>
  <tr>
    <td width="61"><code>%</code></td>
    <td width="100"><code>op1 % op2</code> </td>
    <td width="365">Computes the remainder of dividing <tt>op1</tt> by <tt>op2</tt> </td>
  </tr>
  <tr>
    <td width="61"><code>++</code></td>
    <td width="100"><code>op++</code> </td>
    <td width="365">Increments <code>op</code> by 1; evaluates to value before incrementing </td>
  </tr>
  <tr>
    <td width="61"><code>++</code></td>
    <td width="100"><code>++op</code></td>
    <td width="365">Increments <code>op</code> by 1; evaluates to value after incrementing </td>
  </tr>
  <tr>
    <td width="61"><code>--</code></td>
    <td width="100"><code>op--</code> </td>
    <td width="365">Decrements <code>op</code> by 1; evaluates to value before decrementing</td>
  </tr>
  <tr>
    <td width="61"><code>--</code></td>
    <td width="100"><code>--op</code> </td>
    <td width="365">Decrements <code>op</code> by 1; evaluates to value after decrementing </td>
  </tr>
  <tr>
    <td width="61"><code>+</code> </td>
    <td width="100"><code>+op</code></td>
    <td width="365">Promotes <code>op</code> to <code>int</code> if it's a <code>byte</code>, <code>short</code>,
    or <code>char</code> </td>
  </tr>
  <tr>
    <td width="61"><code>-</code> </td>
    <td width="100"><code>-op</code> </td>
    <td width="365">Arithmetically negates <code>op</code> </td>
  </tr>
</table>

<p>Java does not contain any operator like for Fortran ** operator, you must use the <a href="http://www.javasoft.com/products/jdk/1.1/docs/api/java.lang.Math.html#pow(double, double)">java.lang.Math.pow</a><a href="http://java.sun.com/products/jdk/1.1/api/java.lang.String.html" target="_top"><img alt="(in the API reference documentation)" border="0" height="20" src="apiIcon.gif" width="20"></a> method described under <a href="#Mathematical Functions">Mathematical
Functions</a> below.</p>

<p>Note that the + operator can also be used to concatenate Strings. Other than this one
special case, arithmetic operators can only be used on the built-in Java type, thus even
if you define your own Complex type you will not be able to use the + operator to add
Complex objects together, since Java does not support operator overloading.</p>

<h4>Relational and Conditional Operators</h4>

<p>Relational operators can only be used on boolean operands. Unlike C, Java will not
automatically convert integers to booleans.</p>

<table border="1" cellPadding="5">
  <tr>
    <th height="20">Operator</th>
    <th height="20">Use</th>
    <th height="20">Return <code>true</code> if</th>
  </tr>
  <tr>
    <td height="19"><code>&gt;</code> </td>
    <td height="19"><code>op1 &gt; op2 </code></td>
    <td height="19"><code>op1</code> is greater than <code>op2</code> </td>
  </tr>
  <tr>
    <td height="19"><code>&gt;=</code> </td>
    <td height="19"><code>op1 &gt;= op2</code> </td>
    <td height="19"><code>op1</code> is greater than or equal to <code>op2</code> </td>
  </tr>
  <tr>
    <td height="19"><code>&lt;</code> </td>
    <td height="19"><code>op1 &lt; op2</code> </td>
    <td height="19"><code>op1</code> is less than <code>op2</code> </td>
  </tr>
  <tr>
    <td height="19"><code>&lt;=</code> </td>
    <td height="19"><code>op1 &lt;= op2 </code></td>
    <td height="19"><code>op1</code> is less than or equal to <code>op2</code> </td>
  </tr>
  <tr>
    <td height="19"><code>==</code> </td>
    <td height="19"><code>op1 == op2</code> </td>
    <td height="19"><code>op1</code> and <code>op2</code> are equal </td>
  </tr>
  <tr>
    <td height="16"><code>!=</code> </td>
    <td height="16"><code>op1 != op2 </code></td>
    <td height="16"><code>op1</code> and <code>op2</code> are not equal </td>
  </tr>
  <tr>
    <td height="16"><code>&amp;&amp;</code> </td>
    <td height="16"><code>op1 &amp;&amp; op2</code> </td>
    <td height="16"><code>op1</code> and <code>op2</code> are both <code>true</code>,
    conditionally evaluates <code>op2</code> </td>
  </tr>
  <tr>
    <td height="16"><code>||</code> </td>
    <td height="16"><code>op1 || op2</code> </td>
    <td height="16">either <code>op1</code> or <code>op2</code> is <code>true</code>,
    conditionally evaluates <code>op2</code> </td>
  </tr>
  <tr>
    <td height="16"><code>!</code> </td>
    <td height="16"><code>! op</code> </td>
    <td height="16"><code>op</code> is <code>false</code> </td>
  </tr>
  <tr>
    <td height="16"><code>&amp;</code></td>
    <td height="16"><code>op1 &amp; op2</code> </td>
    <td height="16"><code>op1</code> and <code>op2</code> are both <code>true</code>, always
    evaluates <code>op1</code> and <code>op2</code> </td>
  </tr>
  <tr>
    <td height="16"><code>|</code> </td>
    <td height="16"><code>op1 | op2</code> </td>
    <td height="16">either <code>op1</code> or <code>op2</code> is <code>true</code>, always
    evaluates <code>op1</code> and <code>op2</code> </td>
  </tr>
</table>

<p>One thing to be aware of is that the <code>==</code> operatator will only consider two
references to be equal if they point to the <strong>same</strong> object, thus:</p>

<pre>String a = <span class="key">new</span> String(&quot;xyz&quot;);
String b = <span class="key">new</span> String(&quot;xyz&quot;);
<span class="key">boolean</span> result = (a == b);</pre>

<p>will set result equals to false, even though both strings have the same contents. You
should use the <a href="http://java.sun.com/products/jdk/1.1/docs/api/java.lang.Object.html#equals(java.lang.Object)">Object.equals</a><a href="http://java.sun.com/products/jdk/1.1/api/java.lang.String.html" target="_top"><img alt="(in the API reference documentation)" border="0" height="20" src="apiIcon.gif" width="20"></a> method to compare string for equality:</p>

<pre>String a = <span class="key">new</span> String(&quot;xyz&quot;);
String b = <span class="key">new</span> String(&quot;xyz&quot;);
<span class="key">boolean</span> result = a.equals(b);</pre>

<p>Java supports one other conditional operator--the <code>?:</code> operator. This
operator is a tertiary operator and is basically short-hand for an <code>if</code>-<code>else</code>
statement: </p>

<pre>boolean-expression ? op1 : op2</pre>

<p>The <code>?:</code> operator evaluates <code>boolean-expression</code> and returns <code>op1</code>
if it's true and <code>op2</code> if it's false. </p>

<h4>Bitwise Operators</h4>

<p>Bitwise operators can be used on integer operands.</p>

<table border="1" cellPadding="5">
<tbody>
  <tr>
    <th width="61">Operator</th>
    <th width="114">Use</th>
    <th width="308">Operation</th>
  </tr>
  <tr>
    <td width="61"><code>&gt;&gt;</code> </td>
    <td width="114"><code>op1 &gt;&gt; op2</code> </td>
    <td width="308">shift bits of <code>op1</code> right by distance <code>op2</code> </td>
  </tr>
  <tr>
    <td width="61"><code>&lt;&lt;</code> </td>
    <td width="114"><code>op1 &lt;&lt; op2</code> </td>
    <td width="308">shift bits of <code>op1</code> left by distance <code>op2</code> </td>
  </tr>
  <tr>
    <td width="61"><code>&gt;&gt;&gt;</code> </td>
    <td width="114"><code>op1 &gt;&gt;&gt; op2</code> </td>
    <td width="308">shift bits of <code>op1</code> right by distance <code>op2</code>
    (unsigned) </td>
  </tr>
  <tr>
    <td width="61"><code>&amp;</code> </td>
    <td width="114"><code>op1 &amp; op2</code> </td>
    <td width="308">bitwise <code>and</code> </td>
  </tr>
  <tr>
    <td width="61"><code>|</code> </td>
    <td width="114"><code>op1 | op2</code> </td>
    <td width="308">bitwise <code>or</code> </td>
  </tr>
  <tr>
    <td width="61"><code>^</code> </td>
    <td width="114"><code>op1 ^ op2</code> </td>
    <td width="308">bitwise <code>xor</code> </td>
  </tr>
  <tr>
    <td width="61"><code>~</code> </td>
    <td width="114"><code>~op2</code> </td>
    <td width="308">bitwise complement </td>
  </tr>
</tbody>
</table>

<h4>Assignment Operators</h4>

<p>These assignment operators are just shorthand ways of performing common operations such
as incrementing a variable by a given amount. They are normally clearer (and less prone to
typos) that their longer counterparts.</p>

<table border="1" cellPadding="5">
<tbody>
  <tr>
    <th>Operator</th>
    <th>Use</th>
    <th>Equivalent to</th>
  </tr>
  <tr>
    <td><code>+=</code> </td>
    <td><code>op1 += op2</code> </td>
    <td><code>op1 = op1 + op2</code> </td>
  </tr>
  <tr>
    <td><code>-=</code> </td>
    <td><code>op1 -= op2</code> </td>
    <td><code>op1 = op1 - op2</code> </td>
  </tr>
  <tr>
    <td><code>*=</code> </td>
    <td><code>op1 *= op2</code> </td>
    <td><code>op1 = op1 * op2</code> </td>
  </tr>
  <tr>
    <td><code>/=</code> </td>
    <td><code>op1 /= op2</code> </td>
    <td><code>op1 = op1 / op2</code> </td>
  </tr>
  <tr>
    <td><code>%=</code> </td>
    <td><code>op1 %= op2</code> </td>
    <td><code>op1 = op1 % op2</code> </td>
  </tr>
  <tr>
    <td><code>&amp;=</code> </td>
    <td><code>op1 &amp;= op2 </code></td>
    <td><code>op1 = op1 &amp; op2</code> </td>
  </tr>
  <tr>
    <td><code>|=</code> </td>
    <td><code>op1 |= op2</code> </td>
    <td><code>op1 = op1 | op2</code> </td>
  </tr>
  <tr>
    <td><code>^=</code> </td>
    <td><code>op1 ^= op2</code> </td>
    <td><code>op1 = op1 ^ op2</code> </td>
  </tr>
  <tr>
    <td><code>&lt;&lt;=</code> </td>
    <td><code>op1 &lt;&lt;= op2</code> </td>
    <td><code>op1 = op1 &lt;&lt; op2</code> </td>
  </tr>
  <tr>
    <td><code>&gt;&gt;=</code> </td>
    <td><code>op1 &gt;&gt;= op2</code> </td>
    <td><code>op1 = op1 &gt;&gt; op2</code> </td>
  </tr>
  <tr>
    <td><code>&gt;&gt;&gt;=</code> </td>
    <td><code>op1 &gt;&gt;&gt;= op2</code> </td>
    <td><code>op1 = op1 &gt;&gt;&gt; op2</code> </td>
  </tr>
</tbody>
</table>

<h3><a name="Conditonal and Loop Statements">Conditional and Loop Statements</a></h3>

<p>As you have already seen Java statements all end with <code>;</code> and multiple
statements may be grouped together into a block using curly braces <code>{}</code>. &nbsp;
In addition Java supports all of the loop and conditional statements of the C language
(although long-term Fortran users may be dismayed by the lack of a <code>goto</code>
statement).</p>

<table border="1" cellPadding="5">
<tbody>
  <tr>
    <th>Statement</th>
    <th>Keyword</th>
  </tr>
  <tr>
    <td>decision making </td>
    <td><code>if-else</code>, <code>switch-case</code> </td>
  </tr>
  <tr>
    <td>loop </td>
    <td><code>for</code>, <code>while</code>, <code>do-while </code></td>
  </tr>
  <tr>
    <td>miscellaneous </td>
    <td><code>break</code>, <code>continue</code>, <code>label: </code>, <code>return </code></td>
  </tr>
</tbody>
</table>

<p>The usage of these statements is fairly self-explanatory, as the examples below will
hopefully demonstrate.</p>

<h4>if-else statement</h4>

<pre><span class="key">int</span> testscore;
<span class="key">char</span> grade;

<span class="key">if</span> (testscore &gt;= 90) {
    grade = <span class="string">'A'</span>;
} <span class="key">else if</span> (testscore &gt;= 80) {
    grade = <span class="string">'B'</span>;
} <span class="key">else if</span> (testscore &gt;= 70) {
    grade = <span class="string">'C'</span>;
} <span class="key">else if</span> (testscore &gt;= 60) {
    grade = <span class="string">'D';</span>
} <span class="key">else</span> {
    grade = <span class="string">'F'</span>;
}</pre>

<h4>switch Statement</h4>

<pre><span class="key">int</span> month;
. . .
<span class="key">switch</span> (month) {
<span class="key">case</span> 1:  System.out.println(<span class="string">&quot;January&quot;</span>); <span class="key">break</span>;
<span class="key">case</span> 2:  System.out.println(<span class="string">&quot;February&quot;</span>); <span class="key">break</span>;
<span class="key">case</span> 3:  System.out.println(<span class="string">&quot;March&quot;</span>); <span class="key">break</span>;
<span class="key">case</span> 4:  System.out.println(<span class="string">&quot;April&quot;</span>); <span class="key">break</span>;
<span class="key">case</span> 5:  System.out.println(<span class="string">&quot;May&quot;</span>); <span class="key">break</span>;
<span class="key">case</span> 6:  System.out.println(<span class="string">&quot;June&quot;</span>); <span class="key">break</span>;
<span class="key">case</span> 7:  System.out.println(<span class="string">&quot;July&quot;</span>); <span class="key">break</span>;
<span class="key">case</span> 8:  System.out.println(<span class="string">&quot;August&quot;</span>); <span class="key">break</span>;
<span class="key">case</span> 9:  System.out.println(<span class="string">&quot;September&quot;</span>); <span class="key">break</span>;
<span class="key">case</span> 10: System.out.println(<span class="string">&quot;October&quot;</span>); <span class="key">break</span>;
<span class="key">case</span> 11: System.out.println(<span class="string">&quot;November&quot;</span>); <span class="key">break</span>;
<span class="key">case</span> 12: System.out.println(<span class="string">&quot;December&quot;</span>); <span class="key">break</span>;
<span class="key">default</span>: System.out.println(<span class="string">&quot;Huh?????&quot;</span>); <span class="key">break</span>;
}</pre>

<p>The switch statement inherits C's behavior of &quot;falling through&quot; from one <code>case</code>
to the following <code>case</code> unless an explicit <code>break</code> statement is
inserted after each case as in the above example. Note also the use of the <code>default</code>
statement to catch otherwise unmet cases.</p>

<h4>while and do while statements</h4>

<p>There are two forms of the while loop, one which tests the condition at the 
top of the loop, and one which tests it at the end of the loop (and hence always 
executes the loop body at least once).</p>

<pre><span class="key">int</span> i = 0;
<span class="key">while</span> (i&lt;100)
{
   i++;
}</pre>

<pre><span class="key">int</span> i=0;
<span class="key">do</span>
{
   i++;
} <span class="key">while</span> (i&lt;100);</pre>

<h4>for loop</h4>

<p>The for loop perhaps requires some
explanation for those not familiar with C. The for statement contains three
clauses, separated by semi-colons. The first clause is executed once at the
beginning of the loop, the second clause is executed before each iteration of
the loop, and the third clause is executed at the end of each iteration of the
loop. Any of the clauses can be omitted (although the semi-colons are still
required). The first clause may contain a variable declaration, in which case
the variable is only accessible from within the body of the for loop. The second
clause, if present, must evaluate to a logical expression, and if false the loop
will be exited.</p>

<pre><span class="key">for</span> (<span class="key">int</span> i=0; i&lt;100; i++)
{
   System.out.println(i);
}</pre>

<h4>Miscellaneous statements</h4>

<p>All loop constructs may contain a <span class="dfn">continue statement</span>, meaning that execution
should immediately skip to the next iteration of the loop, or the 
<span class="dfn">break
statement</span>, meaning that the loop should be immediately terminated and 
execution continued from after the loop. Continue and break statements normally 
operate on the innermost loop, although this can be modified by explicitly 
labeling the loop, and using a break or continue statement with a label.</p>

<p>Finally the <span class="dfn">return statement</span> can be used to return 
from a method call. If the method's return type is anything but void the return 
statement must specify a return value.</p>

<h3><a name="Mathematical Functions">Mathematical Functions</a></h3>

<p>Java contains many common mathematical functions as part of the <a href="http://www.javasoft.com/products/jdk/1.1/docs/api/java.lang.Math.html#_top_">java.lang.Math</a><a href="http://java.sun.com/products/jdk/1.1/api/java.lang.String.html" target="_top"><img alt="(in the API reference documentation)" border="0" height="20" src="apiIcon.gif" width="20"></a> built in class. Unfortunately you must always prefix these methods with
the class name (Math), making complicated expressions a bit unwieldy. </p>

<p>The Math class contains two useful constants, <a href="http://www.javasoft.com/products/jdk/1.1/docs/api/java.lang.Math.html#E">Math.E</a><a href="http://java.sun.com/products/jdk/1.1/api/java.lang.String.html" target="_top"><img alt="(in the API reference documentation)" border="0" height="20" src="apiIcon.gif" width="20"></a> and <a href="http://www.javasoft.com/products/jdk/1.1/docs/api/java.lang.Math.html#PI">Math.PI</a><a href="http://java.sun.com/products/jdk/1.1/api/java.lang.String.html" target="_top"><img alt="(in the API reference documentation)" border="0" height="20" src="apiIcon.gif" width="20"></a>, as well as many methods including, <a href="http://www.javasoft.com/products/jdk/1.1/docs/api/java.lang.Math.html#pow(double, double)">Math.pow(double,double)</a><a href="http://java.sun.com/products/jdk/1.1/api/java.lang.String.html" target="_top"><img alt="(in the API reference documentation)" border="0" height="20" src="apiIcon.gif" width="20"></a> (raise to power), <a href="http://www.javasoft.com/products/jdk/1.1/docs/api/java.lang.Math.html#sqrt(double)">Math.sqrt(double)</a><a href="http://java.sun.com/products/jdk/1.1/api/java.lang.String.html" target="_top"><img alt="(in the API reference documentation)" border="0" height="20" src="apiIcon.gif" width="20"></a>, <a href="http://www.javasoft.com/products/jdk/1.1/docs/api/java.lang.Math.html#log(double)">Math.log(double)</a><a href="http://java.sun.com/products/jdk/1.1/api/java.lang.String.html" target="_top"><img alt="(in the API reference documentation)" border="0" height="20" src="apiIcon.gif" width="20"></a> (natural log) and trigonometric functions <a href="http://www.javasoft.com/products/jdk/1.1/docs/api/java.lang.Math.html#sin(double)">Math.sin(double)</a><a href="http://java.sun.com/products/jdk/1.1/api/java.lang.String.html" target="_top"><img alt="(in the API reference documentation)" border="0" height="20" src="apiIcon.gif" width="20"></a>, <a href="http://www.javasoft.com/products/jdk/1.1/docs/api/java.lang.Math.html#cos(double)">Math.cos(double)</a><a href="http://java.sun.com/products/jdk/1.1/api/java.lang.String.html" target="_top"><img alt="(in the API reference documentation)" border="0" height="20" src="apiIcon.gif" width="20"></a> <em>etc</em>. </p>

<p>The Math class also contains a simple random number generator, <a href="http://www.javasoft.com/products/jdk/1.1/docs/api/java.lang.Math.html#random()">Math.random(</a><a href="http://java.sun.com/products/jdk/1.1/api/java.lang.String.html" target="_top"><img alt="(in the API reference documentation)" border="0" height="20" src="apiIcon.gif" width="20"></a><a href="http://www.javasoft.com/products/jdk/1.1/docs/api/java.lang.Math.html#random()">)</a>
which returns a random number in the range 0 to 1. For a more complete random number
generator, which also allows setting and retrieving seeds and generating normally
distributed random numbers, see the class <a href="http://www.javasoft.com/products/jdk/1.1/docs/api/java.util.Random.html#_top_">java.util.Random</a><a href="http://java.sun.com/products/jdk/1.1/api/java.lang.String.html" target="_top"><img alt="(in the API reference documentation)" border="0" height="20" src="apiIcon.gif" width="20"></a>.</p>

<p>Example:</p>

<pre><span class="key">double</span> r = Math.random();
<span class="key">double</span> phi = Math.random()*Math.PI*2;
<span class="key">double</span> x = r*Math.sin(phi);
<span class="key">double</span> y = Math.sqrt(r*r - x*x);</pre>
<h3><a name="Strings">Strings</a></h3>

<p>A sequence of character data is called a string and is implemented in the Java
environment by the <a href="http://java.sun.com/products/jdk/1.1/api/java.lang.String.html" target="_top"><code>String</code><img alt="(in the API reference documentation)" border="0" height="20" src="apiIcon.gif" width="20"></a> class. The Java language contains a few special shortcuts for handling
Strings, for example any occurence of a quoted string constant will automatically be
converted to a String, and the concatenation operator (+) can be used to concatenate two
String together to produce a new String. Finally the concatenation operator (+) can be
used to concatentate a String with any other object, in which case the object is first
converted to a String (using the Object's <a href="http://java.sun.com/products/jdk/1.1/api/java.lang.Object.html#toString()">toString</a><a href="http://java.sun.com/products/jdk/1.1/api/java.lang.String.html" target="_top"><img alt="(in the API reference documentation)" border="0" height="20" src="apiIcon.gif" width="20"></a> method). </p>

<pre>String world = <span class="string">&quot;World&quot;</span>;
System.out.println(<span class="string">&quot;Hello &quot;</span>+world);
System.out.println(<span class="string">&quot;The time is now &quot;</span>+<span class="key">new</span> Date());  </pre>

<p><code>String</code> objects are <span class="dfn">immutable</span>--that is, they
cannot be changed once they've been created. Java provides a different class, <a href="http://java.sun.com/products/jdk/1.1/api/java.lang.StringBuffer.html"><code>StringBuffer</code></a><a href="http://java.sun.com/products/jdk/1.1/api/java.lang.String.html" target="_top"><img alt="(in the API reference documentation)" border="0" height="20" src="apiIcon.gif" width="20"></a>, which you can use to create and manipulate character data on the fly.</p>

<h3><a name="Arrays">Arrays</a></h3>

<p>Arrays in java are handled by array objects. In common with other objects they are
created using the <span class="key">new</span> operator, although the syntax is slightly
modified. The statement:</p>

<pre><span class="key">int</span>[] arrayOfInts = <span class="key">new</span> int[100];</pre>

<p>creates an array containing 100 ints, and assigns a reference to the array to the
variable arrayOfInts. As in C and C++, array elements are numbered from 0, and are
accessed as follows:</p>

<pre><span class="key">for</span> (<span class="key">int</span> i=0; i&lt;arrayOfInts.length; i++) 
   arrayOfInts[i] = 0; </pre>

<p>The member variable <span class="dfn">length</span> can be used to access the dimension
of an array. As well as arrays of all the built-in types, Java also allows arrays of
reference types, such as:</p>

<pre>String[] arrayOfStrings = <span class="key">new</span> String[10];
<span class="key">for</span> (<span class="key">int </span>i = 0; i &lt; arrayOfStrings.length; i++) {
    arrayOfStrings[i] = <span class="key">new</span> String(&quot;Hello &quot; + i);
}</pre>

<p>Like C and C++ Java does not directly support <span class="dfn">multi-dimensional</span>
arrays, but it does support arrays of arrays which give much the same functionality:</p>

<pre><span class="key">double</span>[][] arrayOfArrayOfDoubles = <span class="key">new</span> double[10][3];
<span class="key">for</span> (<span class="key">int</span> i=0; i&lt;10; i++)
   <span class="key">for</span> (<span class="key">int</span> j=0; j&lt;3; j++)
      arrayOfArrayOfDoubles[i][j] = 0;</pre>

<h3><a name="Exceptions">Exceptions</a></h3>

<p>The Java language has built-in support for handling errors, using a mechanism 
known as <span class="dfn">exception handling</span>. To generate an exception 
in your code use the <span class="dfn">throw statement</span>. For example:</p>

<pre><span class="key">if</span> (x &lt; <span class="key">0</span>) <span class="key">throw new</span> IllegalArgumentException(<span class="string">&quot;x must be &gt;= 0&quot;</span>);</pre>
<p>In Java exception are represented by instances of classes which extend
<a target="_top" href="http://java.sun.com/products/jdk/1.1/api/java.lang.Throwable.html">
Throwable<img alt="(in the API reference documentation)" border="0" height="20" src="apiIcon.gif" width="20"></a>. 
Exceptions fall into two categories, <span class="dfn">checked exceptions</span> 
and <span class="dfn">unchecked exceptions</span>. If a method throws a checked 
exception it must explicitly declare that the exception can be thrown, using a
<span class="dfn">throws clause</span>. Declaring unchecked exceptions using a 
throws clause is optional. For example:</p>
<pre><span class="key">public double</span> MySqrt(double x) <span class="key">throws</span> IllegalArgumentException
{
   <span class="key"> if</span> (x &lt; <span class="key">0</span>) <span class="key">throw new</span> IllegalArgumentException(<span class="string">&quot;x must be &gt;= 0&quot;</span>);
    <span class="key">return</span> Math.sqrt(x);
}</pre>
<p>(Note that the Math.sqrt() method does not throw an exception when given a 
negative number, instead it returns a special double value, Double.NaN, which 
represents an undefined number. This is the normal behavior for floating point 
operations in Java).</p>
<p>Unchecked exceptions are those that extend either
<a target="_top" href="http://java.sun.com/products/jdk/1.1/api/java.lang.Error.html">
Error<img alt="(in the API reference documentation)" border="0" height="20" src="apiIcon.gif" width="20"></a> 
or
<a target="_top" href="http://java.sun.com/products/jdk/1.1/api/java.lang.RuntimeException.html">
RuntimeException<img alt="(in the API reference documentation)" border="0" height="20" src="apiIcon.gif" width="20"></a>. 
All other exceptions are checked. In general checked exceptions are used for 
errors that could have been expected to happen in a well defined place (for 
example IO errors when reading a file), whereas unchecked exception are used for 
errors that could happen almost anywhere (for example running out of memory). 
These definitions are however rather vague, so it is often a matter of taste and 
style whether to use a checked or unchecked exception.</p>
<p>You can deal with exceptions in your programs using a try ... catch 
statement. For example:</p>
<pre><span class="key">try</span>
{
   <span class="key">for</span> (<span class="key">int</span> i=0; i&lt;errors.length; i++)
   {
      errors[i] = MySqrt(errors[i]);
   }
}
<span class="key">catch</span> (IllegalArgumentException x)
{
   System.err.println(<span class="string">&quot;Error</span><span class="string"> calculating errors&quot;</span>);
   x.printStackTrace();
}</pre>
<p>If a call to MySqrt results in an exception being throw, the loop will 
immediately be terminated and the body of the catch clause executed. If an 
exception is thrown inside a routine and is not caught using a try ... catch 
statement it is &quot;bubbled up&quot; to the caller of that method, and the caller of the 
caller <i>etc</i>., until either a catch clause is found, or the top level 
routine is reached in which case the exception is reported by Java, and the 
program terminated.</p>

<h3><a name="References">More Information</a></h3>

<ol>
  <li><a href="http://www.javasoft.com/docs/books/tutorial/index.html">Sun's Java Tutorial</a>
    provides a much more complete (and generally better), as well as considerably longer,
    introduction to Java.</li>
</ol>
<hr>
<p>Last Modified: 
<!--webbot bot="Timestamp" S-Type="EDITED" S-Format="%B %d, %Y" startspan -->January 14, 2004<!--webbot bot="Timestamp" endspan i-checksum="31333" -->
</p>
</body>
</html>
