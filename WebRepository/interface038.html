<html>
<title>Using the Java Native Interface with C++</title>
<BODY BGCOLOR="#e0e0e0">
<CENTER><h2>Using the Java Native Interface with C++</h2></CENTER>
<br>

<b>Motivation</b><br>
There are basically two reasons why I chose to explore the <i>Java Native Interface</i> (JNI): Code Reusability and Performance.

<ul>
<li><b>Code Reusability.</b> It may be argued that (superficially) Java is a <i>better</i> C++ (maybe in the way that C++ is a <i>better</i> C). However, the benefits of using Java
at this level do not outweigh the overwhelming task of re-implementing currently tested and debugged C++ code. Given large amounts of proven C++ code, it may be more cost-effective 
to incorporate its functionality into a Java program, rather than to port (re-implement) the C++ functionality in Java. 
<li><b>Performance.</b> Given that Java is interpreted (more or less), one would assume that compiled native code would perform much better. It may be useful to "hand-code" native
methods where speed is critical.</ul>
<br>

<b>The Approach</b><br>
Although JNI documentation is available from Microsoft and Sun, I wanted to create a document/example that contains all of the important aspects of native code interfacing
in one place. I don't just want to reprint what Microsoft and Sun say in their documentation. That would be of no help. In fact, it would probably be of less help. I am a true
believer that a picture is worth a thousand words. Show me an <i>example</i> of a callback on a static void method, (instead of specification explaining every single variation
of a callback), and I can understand it right away. That is the purpose of this exercise. I want to say later, <i>"Hmmm, now how did I pass an object array to C++ and have
it access the components? Let me see, oh yeah, here it is, example #5"</i><br><br>

With the exception of maybe one or two examples, the sample code is my own. I dreamed up examples that I thought would be instructive in understanding how
certain things are done in the Java/native interaction. They are simple enough to be understood merely by looking at the code, yet each are instructive and focused on illustrating
a point. There is basically one Java file that implements the interface to the native C++ code and one C++ file that implements
all of the examples. There is a Java source file, <A HREF="Main.txt">Main.java</A> that is used as the driver program. In essence, there are 3 files needed for these tests:
<ul>
<li><A HREF="Native.txt">Native.java</A> This is the public interface that Java uses to interact with the native C++ functions.
<li><A HREF="Main.txt">Main.java</A> This is the driver program that exercises the examples. It instantiates Java Native objects.
<li><A HREF="Native.cpp">Native.cpp</A> This is the native code that implements the functions that Java will call. It is for Sun's implementation of the JDK. Here is my
<A HREF="ms.native.cpp">source code</A> for Microsoft's JDK. By comparing the two, one can clearly see the different ways that Sun and Microsoft approached
their implementations.
<ul>
<li><A HREF="Nativec.h">Nativec.h</A> This is the machine-generated header file that describes the Java Native class. Generated by Sun's <tt>javah.</tt>
</ul>
</ul>
<br>
Here is a quick and dirty <A HREF="build.txt">batch file</A> to build up the project. It is NOT a make-like file, so if you want to build the project, your machine must be properly configured to begin with. (On a PC, this can be more work than writing the code, and I have no good answers.) 
I got the syntax for compiling a DLL from the command line from Sun's documentation
<A HREF="http://java.sun.com/docs/books/tutorial/native1.1/stepbystep/step5.html">here</A>.
I use the Integrated Development Environment for developing Microsoft-based applications and DLLs. 
<br><br>
There are several issues that I wanted to "solve" in order to satisfy the requirement of reusing existing C++. (Unless otherwise specified, the term <i>native code</i> can be used
interchangeably with the term <i>C++ code</i>.) The essential functionality should include:
<ul>
<li>Calling native code from Java.
<li>Passing parameters to native code from Java. This includes Java Strings, arrays, and other Java objects, as well as basic types (int, long, etc.)
<li>Returning values from native code to Java. This includes Java Strings, arrays, and other Java objects, as well as basic types (int, long, etc.)
<li>Calling Java methods from native code (callbacks). This should include both static and non-static methods.
<li>Accessing fields of Java classes and objects from native code. This should include both static and non-static fields.
<li>Detecting and handling Java exceptions from within native code.
<li>Garbage collection in the JVM should not interfere with native code, and vice-versa. At a minimum, GC is disabled when native code runs.
</ul>
<br>
With the exception of the last point, examples are included that show how each requirement is handled. The problem with GC is that it was difficult to test. I was able to, what
appeared to be, successfully enable/disable GC while in native code, but it was hard to prove this. Microsoft's implementation disables GC while native code is executing. Both Sun
and Microsoft give the programmer control over the lifetime of native pointers to Java objects. This breaks a cardinal rule of Java, safety, but since you are executing C++ code, 
you have pretty much done that already.<br><br>


As for the performance of native code, there are currently three examples that measure how native code performs compared to Java code. 
I would have liked to do more real-world native/Java performance testing, but that would have required a much larger base of Java code. 
I have tons of C++ code, but to be fair, I would like to compare a Java implementation with a C++ implementation. In other words, comparing Java code that
performs the same function as C++ code but uses widely different data structures and algorithms isn't really comparing the same things. It would have required a lot
of work (not related to the task at hand) to "port" enough C++ code to "equivalent" Java code for testing. Thus, only these performance tests were 
implemented: (results are shown at the bottom of the page)
<ul>
<li>Function-call overhead when calling a native method without parameters and no return value. Basically, <tt>void func(void).</tt>
<li>Initializing a large array multiple times.
<li>Sieving prime numbers using a large array.
</ul>

<b>Development Environments</b><br>
I implemented and tested the JNI using both Microsoft's JDK version 1.5.1 and Sun's JDK version 1.1.5. Microsoft refers to its implementation as the <i>Raw Native Interface</i>
(RNI). This seems to be because Microsoft's implementation exposes the implementation details of the Java code, whereas Sun's implementation hides these details, using more
abstract facilities for access. Basically, the JDKs provide header files (.h files) and helper functions, via Dynamic Link Libraries (.dll files) and static Libraries 
(.lib files). Sun's interface is provided through <A HREF="jni.h">jni.h</A> and Microsoft provides an interface via <A HREF="native.h">native.h</A>. Needless to say, these two
implementations, Microsoft's RNI and Sun's JNI, are incompatible. The methodology is related, but the syntax is not. Note that this incompatibility is only at the native code level,
that is, at the C++ level. The Java code is compatible. Therefore, there is one implementation of <A HREF="Native.txt">Native.java</A>, one implementation of
<A HREF="Main.txt">Main.java</A>, but two implementations of <A HREF="Native.cpp">Native.cpp</A>, one for Microsoft's JDK, and one for Sun's JDK.<br><br>


The "Microsoft" implementation uses:
<ul>
<li>Microsoft's JDK 1.5.1 for run-time support.
<li>Microsoft's Visual C++ 5.0 for developing the native code.
<li>Microsoft's Visual J++ 1.1 for developing the Java code.
</ul>
<br>

The "Sun" implementation uses:
<ul>
<li>Sun's JDK 1.1.5 for developing the Java code and to provide the run-time support.
<li>Microsoft's Visual C++ 5.0 for developing the native code.
</ul>
<br>

The runtime environment used to time the tests:
<ul>
<li>Intel Pentium II 233 MHz (running at 266 MHz) with 128 MB of RAM
<li>Windows NT 4.0 (with Service Pack 3)
</ul>
<br>

Originally, I implemented all tests and timings with Microsoft's kit, and it <i>appeared</i> that it was going to be very similar to how Sun's documentation explained things.
After about 20 hours of code development with the Microsoft stuff, I began development with Sun's kit. After about 8 hours with Sun's kit, I started to <i>really</i> 
understand what was going on. I made more elaborate use of objects and callbacks to access Java classes and objects. By the time I finished the second implementation (using Sun's JDK), I had a very different set of functionality than
what I originally had with Microsoft. I decided to use the Sun implementation as the basis for re-implementing the Microsoft code. This went pretty smoothly.
By looking at the header files created by Microsoft's <tt>msjavah</tt> and Sun's <tt>javah</tt>, you can see
that Sun's approach is more of an interface rather than Microsoft's code. Here is Microsoft's "interface" to the native code <A HREF="ms.native.h">Microsoft's header file</A>, 
and here is Sun's interface <A HREF="sun.native.h">Sun's header file</A>. It is interesting to note that Sun can generate the same header file as Microsoft, but given a
switch <tt>-jni</tt>, Sun's tool generates the one shown here. Exposing the implementation is not necessarily a bad thing. When the implementation is exposed, as in 
Microsoft's header file, the native code can <i>directly</i> access the members (either public or private). With Sun's header file, you <i>must</i> use JNI methods 
to gain access. Direct access looks something like this:
<pre>
  // self is basically the 'this' pointer
long __cdecl Native_getX (HNative *self)
{
  return self->x;
}
</pre>



This can't be done using Sun's header files, because the members are not exposed. Only method interfaces are given. Access to the members requires JNI function calls
which are shown in the sample code.
The public and private access specifiers have no effect on native code accessing members. I believe this is because the JDK generates "C" code and not
C++ code. If you use a C++ compiler, you can manually modify the structures (a class with public access by default in C++) to include the access. 
The structure below includes a <tt>private</tt> modifier so the code above would generate a compiler warning when trying to directly access <tt>x</tt> via the
<tt>self</tt> pointer.

<pre>
typedef struct ClassNative {
  struct Hjava_lang_String * string_;
  long boolean_;
  long byte_;
  long char_;
  double double_;
  float float_;
  long int_;
  int64_t long_;
  long short_;

  // now w, x, and y are private and cannot be accessed directly
private:

  struct Hjava_lang_String * w;
  long x;
  long y;
} ClassNative;
</pre>

<br>

<b>Browsing the Results</b><br>
This document is fairly brief, providing just the overview of the process of exploring the JNI. The real information is in the 4 implementation files described above. Particularly,
the <A HREF="Native.cpp">Native.cpp</A> has a wealth of information. There are 12 functions defined within the file, and each function shows at least one aspect of JNI programming. 
Many functions use several JNI mechanisms to accomplish their specific task. <A HREF="Native.txt">Native.java</A> is basically redundant. Once you know how to declare one native
function, you can declare them all. The power is in Sun's <tt>javah</tt> (Microsoft's <tt>msjavah</tt>) that constructs C equivalents to Java's types. 
<A HREF="Main.txt">Main.java</A> shows how you would invoke the native methods, although as you'll see, it's impossible to distinguish between calling a Java method or a native
C++ method. Those details are hidden in the Java Native class.<br><br>

In the proverbial nutshell, here is the performance comparison: (here's a <A HREF="output.txt">sample</A> output) 
<pre>
                                     Windows NT      Solaris
                                   Sun   Microsoft     Sun

1. Native Prime Sieve              405      315        390
   Java Prime Sieve               1510      320       2660

2. Native Function Calls           925      320        980
   Java Function Calls             150       40        275                                 

3. Native Array Initialize         465      <10        715
   Java Array Initialize          3670      270       5080

4. Callbacks to Java void         1510     1660       1250
   Java calls to native void       930      210       1000


5. Callbacks to Java cons.   200    50       50         50  
   Java calls to constructor        50       50         40
                             300    80       70         90
                                    70       70         55
                             400   110      100        120 
                                    90      110         75 
                             500   150      130        150
                                   130      120        110

                             1K    370       F         280 *
                                   270       A         220       
                             2K    910       I         760 *
                                   570       L         440
                             3K   1680       E        1530 *
                                   820       D         680
                             4K   2640                2480 *
                                  1130                 900

</pre>

All times are in milliseconds<br>
<ol>
<li>Prime numbers were sieved up to 1,000,000
<li>1,000,000 function calls
<li>An array of 10,000 elements was initialized 1,000 times.
<li>1,000,000 calls were made from native to Java, and from Java to native.
<li>8 tests were done. (200, 300, 400, 500, 1000, 2000, 3000, 4000 calls). For reasons that I
can't yet explain, Microsoft's implementation failed when trying to construct about 750 objects.<br><br>
</ol>

<b>*</b> The interesting note is that the time taken in calling Java constructors from native does not
increase at a linear rate. This was true on both NT and Solaris.
<br>

<br><br>

A useful table to have while studying the JNI is the mappings between Java types and C++ types. Rather than copy it myself, why don't I just point to it. This is the same
document that I used while developing this code. You can also navigate to other topics related to JNI programming.<br><br>
<A HREF="http://java.sun.com/docs/books/tutorial/native1.1/implementing/types.html">Mapping between Java types and Native types</A><br>
<A HREF="http://java.sun.com/docs/books/tutorial/native1.1/stepbystep/index.html">Step by step tutorial</A>

<br><br>

My other JNI work:
<ul>
<li><A HREF="http://home.pacifier.com/~mmead/jni/cs510ajp/index.html">
<!-- <A HREF="http://www.cs.pdx.edu/~antoy/Courses/Advanced/units/jni/index.html"> -->
Programming with the Java Native Interface</a> This is a tutorial that shows how to use C++ with
the Java Native Interface on Linux, Solaris, and Windows NT. 
<li><A HREF="http://www.pacifier.com/~mmead/jni/delphi/">
Using the Java Native Interface with Delphi.</A> These pages describe how to use
the Java Native Interface with Delphi. Part two of 
<i>Using the Java Native Interface with Delphi</i> is essentially a port of the C/C++
code found on this page to Delphi. Much of the Java code is the same. There is also an in-depth tutorial.
</ul>

<b>Updates</b><br>
<i>12-18-98</i>
Added an example to demonstrate passing a 2-D array to a native method. 
Only <A HREF="Native.cpp">Native.cpp</A> (Sun-compatible code) was updated. Microsoft-compatible code, <A HREF="ms.native.cpp">ms.native.cpp</A>, was not altered to reflect this new example.


<br><br><hr WIDTH="90%"><br>
<!--
If there are any problems or questions, or if I forgot something, please let <A HREF="mailto:jni@matthewmead.com?Subject=Using the JNI with C/C++">me</A> know.
-->

<p>
<img src="http://ftp.matthewmead.com:8181/counters/counter.exe?FileName=PAC-CS510jip2&Txt2=You%20are%20visitor%20number%20%%d%20since%2010/31/2000.&FontName=Arial&FontSize=10&FontColor=clBlack&BackgroundColor=$E0E0E0"">
</body>
</html>






























